using Microsoft.OpenApi.Expressions;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using YandexSpeech.Migrations;
using YandexSpeech.services;
using YoutubeExplode;
using YoutubeExplode.Common;
using YoutubeExplode.Videos;
using YoutubeExplode.Videos.ClosedCaptions;

namespace YoutubeDownload.Services
{
    public class SubtitlesNotFoundException : Exception
    {
        public SubtitlesNotFoundException(string message) : base(message) { }
    }

    /// <summary>
    /// Класс для хранения информации о видео: название, автор и дата публикации.
    /// </summary>
    public class VideoInfo
    {
        public string Title { get; set; }
        public Author Author { get; set; }

        // Новое поле для даты публикации видео
        public DateTimeOffset? UploadDate { get; set; }
    }

    public class CaptionService
    {
        private readonly YoutubeClient _youtubeClient;

        public CaptionService(YoutubeClient youtubeClient)
        {
            _youtubeClient = youtubeClient;
        }

        /// <summary>
        /// Возвращает информацию о видео (название, автор, дата публикации) по указанному YouTube ID.
        /// </summary>
        /// <param name="youtubeId">ID видео на YouTube</param>
        /// <returns>Объект VideoInfo с информацией о видео и канале</returns>
        public async Task<VideoInfo> GetVideoInfoAsync(string youtubeId)
        {
            var video = await _youtubeClient.Videos.GetAsync(youtubeId);

            return new VideoInfo
            {
                Title = video.Title,
                Author = video.Author,
                UploadDate = video.UploadDate // Добавляем дату публикации
            };
        }

        /// <summary>
        /// Получает список доступных субтитров для видео.
        /// </summary>
        /// <param name="youtubeId">ID видео на YouTube</param>
        /// <returns>Список информации о доступных субтитрах</returns>
        public async Task<List<ClosedCaptionTrackInfo>> GetAvailableSubtitlesAsync(string youtubeId)
        {
            var manifest = await _youtubeClient.Videos.ClosedCaptions.GetManifestAsync(youtubeId);
            return manifest.Tracks.ToList();
        }

        /// <summary>
        /// Получает массив фраз из субтитров YouTube по ID видео и ID субтитра.
        /// Если ID субтитра не указан, выбирается первый доступный или автоматический.
        /// </summary>
        /// <param name="youtubeId">ID видео на YouTube</param>
        /// <param name="subtitleUrl">URL субтитров (может быть кодом языка)</param>
        /// <returns>Список фраз</returns>
        public async Task<List<ClosedCaption>> GetCaptionsAsync(string youtubeId, string? subtitleUrl = null)
        {
            var manifest = await _youtubeClient.Videos.ClosedCaptions.GetManifestAsync(youtubeId);

            if (manifest.Tracks.Count == 0)
                throw new SubtitlesNotFoundException("Subtitles not available for this video");

            // Если нет автогенерированных субтитров и не указаны, по умолчанию используем "en"
            if (!manifest.Tracks.Any(x => x.IsAutoGenerated))
                if (subtitleUrl == null)
                    subtitleUrl = "en";

            // Если пользователь не указал конкретный язык, 
            // пытаемся взять автогенерированные, иначе берём первый доступный
            var trackInfo = string.IsNullOrEmpty(subtitleUrl)
                ? manifest.Tracks.FirstOrDefault(t => t.IsAutoGenerated) ?? manifest.Tracks.FirstOrDefault()
                : manifest.Tracks.FirstOrDefault(t => t.Language.Code == subtitleUrl);

            // Ещё одна проверка: если trackInfo всё ещё null – берём любой доступный трек
            if (trackInfo == null)
                trackInfo = manifest.Tracks.FirstOrDefault();

            if (trackInfo == null)
            {
                // Если и после этого ничего не найдено – проблема с сетью или недоступные субтитры
                throw new HttpRequestException("Network error or subtitles are unavailable");
            }

            var track = await _youtubeClient.Videos.ClosedCaptions.GetAsync(trackInfo);
            return track.Captions.ToList();
        }

        /// <summary>
        /// Разбивает субтитры на блоки (сегменты) для дальнейшей обработки.
        /// </summary>
        /// <param name="captions">Список субтитров</param>
        /// <param name="maxWordsInSegment">Максимальное количество слов в сегменте</param>
        /// <param name="pauseThreshold">Порог паузы (в секундах) для разбиения</param>
        /// <returns>Список строк, представляющих блоки текста</returns>
        public List<string> SegmentCaptions(List<ClosedCaption> captions, int maxWordsInSegment = 50, double pauseThreshold = 1.0)
        {
            if (captions == null || !captions.Any())
            {
                Console.WriteLine("Входной список субтитров пуст.");
                return new List<string>();
            }

            Console.WriteLine($"Количество субтитров для обработки: {captions.Count}");

            var phrases = captions.Select(c => new Phrase
            {
                Text = c.Text,
                StartTime = c.Offset,
                EndTime = c.Offset + c.Duration,
                WordCount = c.Text.Split(' ', StringSplitOptions.RemoveEmptyEntries).Length
            }).ToList();

            if (!phrases.Any())
            {
                Console.WriteLine("Список фраз после преобразования пуст.");
                return new List<string>();
            }

            Console.WriteLine($"Количество фраз для сегментации: {phrases.Count}");

            var segments = TextSegmenter.SplitIntoSegments(
                new RecognizeResult
                {
                    response = new RecognizeResponse
                    {
                        chunks = phrases.Select(p => new Chunk
                        {
                            alternatives = new List<Alternative>
                            {
                                new Alternative
                                {
                                    text = p.Text,
                                    words = GenerateWords(p.Text, p.StartTime, p.EndTime)
                                }
                            }
                        }).ToList()
                    }
                },
                maxWordsInSegment: maxWordsInSegment,
                pauseThreshold: pauseThreshold,
                channel: 0
            );

            if (segments == null || !segments.Any())
            {
                Console.WriteLine("Метод сегментации вернул пустой результат.");
                return new List<string>();
            }

            Console.WriteLine($"Количество сегментов после обработки: {segments.Count}");
            return segments;
        }

        /// <summary>
        /// Генерирует список слов (с таймингами) для одной фразы субтитров.
        /// </summary>
        /// <param name="text">Текст субтитра</param>
        /// <param name="startTime">Начальное время субтитра</param>
        /// <param name="endTime">Конечное время субтитра</param>
        /// <returns>Список объектов Word</returns>
        private List<Word> GenerateWords(string text, TimeSpan startTime, TimeSpan endTime)
        {
            var words = text.Split(' ', StringSplitOptions.RemoveEmptyEntries);
            var wordCount = words.Length;

            if (wordCount == 0)
                return new List<Word>();

            var durationPerWord = (endTime - startTime).TotalSeconds / wordCount;

            var result = new List<Word>();
            for (int i = 0; i < wordCount; i++)
            {
                var wordStartTime = startTime.Add(TimeSpan.FromSeconds(i * durationPerWord));
                var wordEndTime = wordStartTime.Add(TimeSpan.FromSeconds(durationPerWord));

                result.Add(new Word
                {
                    word = words[i],
                    confidence = 1.0f,
                    startTimeSpan = wordStartTime,
                    endTimeSpan = wordEndTime
                });
            }

            return result;
        }
    }
}
